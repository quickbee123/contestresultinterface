"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.accountForExecutorNone = exports.TvmErrorCode = exports.UtilsModule = exports.addressStringFormatBase64 = exports.addressStringFormatHex = exports.addressStringFormatAccountId = exports.ProcessingModule = exports.processingEventMessageExpired = exports.processingEventFetchNextBlockFailed = exports.processingEventWillFetchNextBlock = exports.processingEventSendFailed = exports.processingEventDidSend = exports.processingEventWillSend = exports.processingEventFetchFirstBlockFailed = exports.processingEventWillFetchFirstBlock = exports.ProcessingErrorCode = exports.BocModule = exports.builderOpCellBoc = exports.builderOpCell = exports.builderOpBitString = exports.builderOpInteger = exports.BocErrorCode = exports.bocCacheTypeUnpinned = exports.bocCacheTypePinned = exports.AbiModule = exports.messageSourceEncodingParams = exports.messageSourceEncoded = exports.stateInitSourceTvc = exports.stateInitSourceStateInit = exports.stateInitSourceMessage = exports.MessageBodyType = exports.signerSigningBox = exports.signerKeys = exports.signerExternal = exports.signerNone = exports.abiSerialized = exports.abiHandle = exports.abiJson = exports.abiContract = exports.AbiErrorCode = exports.CryptoModule = exports.resultOfAppSigningBoxSign = exports.resultOfAppSigningBoxGetPublicKey = exports.paramsOfAppSigningBoxSign = exports.paramsOfAppSigningBoxGetPublicKey = exports.CryptoErrorCode = exports.ClientModule = exports.appRequestResultOk = exports.appRequestResultError = exports.ClientErrorCode = void 0;
exports.DebotModule = exports.resultOfAppDebotBrowserInvokeDebot = exports.resultOfAppDebotBrowserGetSigningBox = exports.resultOfAppDebotBrowserInput = exports.paramsOfAppDebotBrowserSend = exports.paramsOfAppDebotBrowserInvokeDebot = exports.paramsOfAppDebotBrowserGetSigningBox = exports.paramsOfAppDebotBrowserInput = exports.paramsOfAppDebotBrowserShowAction = exports.paramsOfAppDebotBrowserSwitchCompleted = exports.paramsOfAppDebotBrowserSwitch = exports.paramsOfAppDebotBrowserLog = exports.DebotErrorCode = exports.NetModule = exports.AggregationFn = exports.paramsOfQueryOperationAggregateCollection = exports.paramsOfQueryOperationWaitForCollection = exports.paramsOfQueryOperationQueryCollection = exports.SortDirection = exports.NetErrorCode = exports.TvmModule = exports.accountForExecutorAccount = exports.accountForExecutorUninit = void 0;
// client module
var ClientErrorCode;
(function (ClientErrorCode) {
    ClientErrorCode[ClientErrorCode["NotImplemented"] = 1] = "NotImplemented";
    ClientErrorCode[ClientErrorCode["InvalidHex"] = 2] = "InvalidHex";
    ClientErrorCode[ClientErrorCode["InvalidBase64"] = 3] = "InvalidBase64";
    ClientErrorCode[ClientErrorCode["InvalidAddress"] = 4] = "InvalidAddress";
    ClientErrorCode[ClientErrorCode["CallbackParamsCantBeConvertedToJson"] = 5] = "CallbackParamsCantBeConvertedToJson";
    ClientErrorCode[ClientErrorCode["WebsocketConnectError"] = 6] = "WebsocketConnectError";
    ClientErrorCode[ClientErrorCode["WebsocketReceiveError"] = 7] = "WebsocketReceiveError";
    ClientErrorCode[ClientErrorCode["WebsocketSendError"] = 8] = "WebsocketSendError";
    ClientErrorCode[ClientErrorCode["HttpClientCreateError"] = 9] = "HttpClientCreateError";
    ClientErrorCode[ClientErrorCode["HttpRequestCreateError"] = 10] = "HttpRequestCreateError";
    ClientErrorCode[ClientErrorCode["HttpRequestSendError"] = 11] = "HttpRequestSendError";
    ClientErrorCode[ClientErrorCode["HttpRequestParseError"] = 12] = "HttpRequestParseError";
    ClientErrorCode[ClientErrorCode["CallbackNotRegistered"] = 13] = "CallbackNotRegistered";
    ClientErrorCode[ClientErrorCode["NetModuleNotInit"] = 14] = "NetModuleNotInit";
    ClientErrorCode[ClientErrorCode["InvalidConfig"] = 15] = "InvalidConfig";
    ClientErrorCode[ClientErrorCode["CannotCreateRuntime"] = 16] = "CannotCreateRuntime";
    ClientErrorCode[ClientErrorCode["InvalidContextHandle"] = 17] = "InvalidContextHandle";
    ClientErrorCode[ClientErrorCode["CannotSerializeResult"] = 18] = "CannotSerializeResult";
    ClientErrorCode[ClientErrorCode["CannotSerializeError"] = 19] = "CannotSerializeError";
    ClientErrorCode[ClientErrorCode["CannotConvertJsValueToJson"] = 20] = "CannotConvertJsValueToJson";
    ClientErrorCode[ClientErrorCode["CannotReceiveSpawnedResult"] = 21] = "CannotReceiveSpawnedResult";
    ClientErrorCode[ClientErrorCode["SetTimerError"] = 22] = "SetTimerError";
    ClientErrorCode[ClientErrorCode["InvalidParams"] = 23] = "InvalidParams";
    ClientErrorCode[ClientErrorCode["ContractsAddressConversionFailed"] = 24] = "ContractsAddressConversionFailed";
    ClientErrorCode[ClientErrorCode["UnknownFunction"] = 25] = "UnknownFunction";
    ClientErrorCode[ClientErrorCode["AppRequestError"] = 26] = "AppRequestError";
    ClientErrorCode[ClientErrorCode["NoSuchRequest"] = 27] = "NoSuchRequest";
    ClientErrorCode[ClientErrorCode["CanNotSendRequestResult"] = 28] = "CanNotSendRequestResult";
    ClientErrorCode[ClientErrorCode["CanNotReceiveRequestResult"] = 29] = "CanNotReceiveRequestResult";
    ClientErrorCode[ClientErrorCode["CanNotParseRequestResult"] = 30] = "CanNotParseRequestResult";
    ClientErrorCode[ClientErrorCode["UnexpectedCallbackResponse"] = 31] = "UnexpectedCallbackResponse";
    ClientErrorCode[ClientErrorCode["CanNotParseNumber"] = 32] = "CanNotParseNumber";
    ClientErrorCode[ClientErrorCode["InternalError"] = 33] = "InternalError";
})(ClientErrorCode = exports.ClientErrorCode || (exports.ClientErrorCode = {}));
function appRequestResultError(text) {
    return {
        type: 'Error',
        text,
    };
}
exports.appRequestResultError = appRequestResultError;
function appRequestResultOk(result) {
    return {
        type: 'Ok',
        result,
    };
}
exports.appRequestResultOk = appRequestResultOk;
/**
 * Provides information about library.
 */
class ClientModule {
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns Core Library API reference
     * @returns ResultOfGetApiReference
     */
    get_api_reference() {
        return this.client.request('client.get_api_reference');
    }
    /**
     * Returns Core Library version
     * @returns ResultOfVersion
     */
    version() {
        return this.client.request('client.version');
    }
    /**
     * Returns detailed information about this build.
     * @returns ResultOfBuildInfo
     */
    build_info() {
        return this.client.request('client.build_info');
    }
    /**
     * Resolves application request processing result
     *
     * @param {ParamsOfResolveAppRequest} params
     * @returns
     */
    resolve_app_request(params) {
        return this.client.request('client.resolve_app_request', params);
    }
}
exports.ClientModule = ClientModule;
// crypto module
var CryptoErrorCode;
(function (CryptoErrorCode) {
    CryptoErrorCode[CryptoErrorCode["InvalidPublicKey"] = 100] = "InvalidPublicKey";
    CryptoErrorCode[CryptoErrorCode["InvalidSecretKey"] = 101] = "InvalidSecretKey";
    CryptoErrorCode[CryptoErrorCode["InvalidKey"] = 102] = "InvalidKey";
    CryptoErrorCode[CryptoErrorCode["InvalidFactorizeChallenge"] = 106] = "InvalidFactorizeChallenge";
    CryptoErrorCode[CryptoErrorCode["InvalidBigInt"] = 107] = "InvalidBigInt";
    CryptoErrorCode[CryptoErrorCode["ScryptFailed"] = 108] = "ScryptFailed";
    CryptoErrorCode[CryptoErrorCode["InvalidKeySize"] = 109] = "InvalidKeySize";
    CryptoErrorCode[CryptoErrorCode["NaclSecretBoxFailed"] = 110] = "NaclSecretBoxFailed";
    CryptoErrorCode[CryptoErrorCode["NaclBoxFailed"] = 111] = "NaclBoxFailed";
    CryptoErrorCode[CryptoErrorCode["NaclSignFailed"] = 112] = "NaclSignFailed";
    CryptoErrorCode[CryptoErrorCode["Bip39InvalidEntropy"] = 113] = "Bip39InvalidEntropy";
    CryptoErrorCode[CryptoErrorCode["Bip39InvalidPhrase"] = 114] = "Bip39InvalidPhrase";
    CryptoErrorCode[CryptoErrorCode["Bip32InvalidKey"] = 115] = "Bip32InvalidKey";
    CryptoErrorCode[CryptoErrorCode["Bip32InvalidDerivePath"] = 116] = "Bip32InvalidDerivePath";
    CryptoErrorCode[CryptoErrorCode["Bip39InvalidDictionary"] = 117] = "Bip39InvalidDictionary";
    CryptoErrorCode[CryptoErrorCode["Bip39InvalidWordCount"] = 118] = "Bip39InvalidWordCount";
    CryptoErrorCode[CryptoErrorCode["MnemonicGenerationFailed"] = 119] = "MnemonicGenerationFailed";
    CryptoErrorCode[CryptoErrorCode["MnemonicFromEntropyFailed"] = 120] = "MnemonicFromEntropyFailed";
    CryptoErrorCode[CryptoErrorCode["SigningBoxNotRegistered"] = 121] = "SigningBoxNotRegistered";
    CryptoErrorCode[CryptoErrorCode["InvalidSignature"] = 122] = "InvalidSignature";
})(CryptoErrorCode = exports.CryptoErrorCode || (exports.CryptoErrorCode = {}));
function paramsOfAppSigningBoxGetPublicKey() {
    return {
        type: 'GetPublicKey',
    };
}
exports.paramsOfAppSigningBoxGetPublicKey = paramsOfAppSigningBoxGetPublicKey;
function paramsOfAppSigningBoxSign(unsigned) {
    return {
        type: 'Sign',
        unsigned,
    };
}
exports.paramsOfAppSigningBoxSign = paramsOfAppSigningBoxSign;
function resultOfAppSigningBoxGetPublicKey(public_key) {
    return {
        type: 'GetPublicKey',
        public_key,
    };
}
exports.resultOfAppSigningBoxGetPublicKey = resultOfAppSigningBoxGetPublicKey;
function resultOfAppSigningBoxSign(signature) {
    return {
        type: 'Sign',
        signature,
    };
}
exports.resultOfAppSigningBoxSign = resultOfAppSigningBoxSign;
function dispatchAppSigningBox(obj, params, app_request_id, client) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            let result = {};
            switch (params.type) {
                case 'GetPublicKey':
                    result = yield obj.get_public_key();
                    break;
                case 'Sign':
                    result = yield obj.sign(params);
                    break;
            }
            client.resolve_app_request(app_request_id, Object.assign({ type: params.type }, result));
        }
        catch (error) {
            client.reject_app_request(app_request_id, error);
        }
    });
}
/**
 * Crypto functions.
 */
class CryptoModule {
    constructor(client) {
        this.client = client;
    }
    /**
     * Performs prime factorization – decomposition of a composite number into a product of smaller prime integers (factors). See [https://en.wikipedia.org/wiki/Integer_factorization]
     *
     * @param {ParamsOfFactorize} params
     * @returns ResultOfFactorize
     */
    factorize(params) {
        return this.client.request('crypto.factorize', params);
    }
    /**
     * Performs modular exponentiation for big integers (`base`^`exponent` mod `modulus`). See [https://en.wikipedia.org/wiki/Modular_exponentiation]
     *
     * @param {ParamsOfModularPower} params
     * @returns ResultOfModularPower
     */
    modular_power(params) {
        return this.client.request('crypto.modular_power', params);
    }
    /**
     * Calculates CRC16 using TON algorithm.
     *
     * @param {ParamsOfTonCrc16} params
     * @returns ResultOfTonCrc16
     */
    ton_crc16(params) {
        return this.client.request('crypto.ton_crc16', params);
    }
    /**
     * Generates random byte array of the specified length and returns it in `base64` format
     *
     * @param {ParamsOfGenerateRandomBytes} params
     * @returns ResultOfGenerateRandomBytes
     */
    generate_random_bytes(params) {
        return this.client.request('crypto.generate_random_bytes', params);
    }
    /**
     * Converts public key to ton safe_format
     *
     * @param {ParamsOfConvertPublicKeyToTonSafeFormat} params
     * @returns ResultOfConvertPublicKeyToTonSafeFormat
     */
    convert_public_key_to_ton_safe_format(params) {
        return this.client.request('crypto.convert_public_key_to_ton_safe_format', params);
    }
    /**
     * Generates random ed25519 key pair.
     * @returns KeyPair
     */
    generate_random_sign_keys() {
        return this.client.request('crypto.generate_random_sign_keys');
    }
    /**
     * Signs a data using the provided keys.
     *
     * @param {ParamsOfSign} params
     * @returns ResultOfSign
     */
    sign(params) {
        return this.client.request('crypto.sign', params);
    }
    /**
     * Verifies signed data using the provided public key. Raises error if verification is failed.
     *
     * @param {ParamsOfVerifySignature} params
     * @returns ResultOfVerifySignature
     */
    verify_signature(params) {
        return this.client.request('crypto.verify_signature', params);
    }
    /**
     * Calculates SHA256 hash of the specified data.
     *
     * @param {ParamsOfHash} params
     * @returns ResultOfHash
     */
    sha256(params) {
        return this.client.request('crypto.sha256', params);
    }
    /**
     * Calculates SHA512 hash of the specified data.
     *
     * @param {ParamsOfHash} params
     * @returns ResultOfHash
     */
    sha512(params) {
        return this.client.request('crypto.sha512', params);
    }
    /**
     * Derives key from `password` and `key` using `scrypt` algorithm. See [https://en.wikipedia.org/wiki/Scrypt].
     *
     * @remarks
     * # Arguments
     * - `log_n` - The log2 of the Scrypt parameter `N`
     * - `r` - The Scrypt parameter `r`
     * - `p` - The Scrypt parameter `p`
     * # Conditions
     * - `log_n` must be less than `64`
     * - `r` must be greater than `0` and less than or equal to `4294967295`
     * - `p` must be greater than `0` and less than `4294967295`
     * # Recommended values sufficient for most use-cases
     * - `log_n = 15` (`n = 32768`)
     * - `r = 8`
     * - `p = 1`
     *
     * @param {ParamsOfScrypt} params
     * @returns ResultOfScrypt
     */
    scrypt(params) {
        return this.client.request('crypto.scrypt', params);
    }
    /**
     * Generates a key pair for signing from the secret key
     *
     * @param {ParamsOfNaclSignKeyPairFromSecret} params
     * @returns KeyPair
     */
    nacl_sign_keypair_from_secret_key(params) {
        return this.client.request('crypto.nacl_sign_keypair_from_secret_key', params);
    }
    /**
     * Signs data using the signer's secret key.
     *
     * @param {ParamsOfNaclSign} params
     * @returns ResultOfNaclSign
     */
    nacl_sign(params) {
        return this.client.request('crypto.nacl_sign', params);
    }
    /**
     * Verifies the signature and returns the unsigned message
     *
     * @remarks
     * Verifies the signature in `signed` using the signer's public key `public`
     * and returns the message `unsigned`.
     *
     * If the signature fails verification, crypto_sign_open raises an exception.
     *
     * @param {ParamsOfNaclSignOpen} params
     * @returns ResultOfNaclSignOpen
     */
    nacl_sign_open(params) {
        return this.client.request('crypto.nacl_sign_open', params);
    }
    /**
     * Signs the message using the secret key and returns a signature.
     *
     * @remarks
     * Signs the message `unsigned` using the secret key `secret`
     * and returns a signature `signature`.
     *
     * @param {ParamsOfNaclSign} params
     * @returns ResultOfNaclSignDetached
     */
    nacl_sign_detached(params) {
        return this.client.request('crypto.nacl_sign_detached', params);
    }
    /**
     * Verifies the signature with public key and `unsigned` data.
     *
     * @param {ParamsOfNaclSignDetachedVerify} params
     * @returns ResultOfNaclSignDetachedVerify
     */
    nacl_sign_detached_verify(params) {
        return this.client.request('crypto.nacl_sign_detached_verify', params);
    }
    /**
     * Generates a random NaCl key pair
     * @returns KeyPair
     */
    nacl_box_keypair() {
        return this.client.request('crypto.nacl_box_keypair');
    }
    /**
     * Generates key pair from a secret key
     *
     * @param {ParamsOfNaclBoxKeyPairFromSecret} params
     * @returns KeyPair
     */
    nacl_box_keypair_from_secret_key(params) {
        return this.client.request('crypto.nacl_box_keypair_from_secret_key', params);
    }
    /**
     * Public key authenticated encryption
     *
     * @remarks
     * Encrypt and authenticate a message using the senders secret key, the receivers public
     * key, and a nonce.
     *
     * @param {ParamsOfNaclBox} params
     * @returns ResultOfNaclBox
     */
    nacl_box(params) {
        return this.client.request('crypto.nacl_box', params);
    }
    /**
     * Decrypt and verify the cipher text using the receivers secret key, the senders public key, and the nonce.
     *
     * @param {ParamsOfNaclBoxOpen} params
     * @returns ResultOfNaclBoxOpen
     */
    nacl_box_open(params) {
        return this.client.request('crypto.nacl_box_open', params);
    }
    /**
     * Encrypt and authenticate message using nonce and secret key.
     *
     * @param {ParamsOfNaclSecretBox} params
     * @returns ResultOfNaclBox
     */
    nacl_secret_box(params) {
        return this.client.request('crypto.nacl_secret_box', params);
    }
    /**
     * Decrypts and verifies cipher text using `nonce` and secret `key`.
     *
     * @param {ParamsOfNaclSecretBoxOpen} params
     * @returns ResultOfNaclBoxOpen
     */
    nacl_secret_box_open(params) {
        return this.client.request('crypto.nacl_secret_box_open', params);
    }
    /**
     * Prints the list of words from the specified dictionary
     *
     * @param {ParamsOfMnemonicWords} params
     * @returns ResultOfMnemonicWords
     */
    mnemonic_words(params) {
        return this.client.request('crypto.mnemonic_words', params);
    }
    /**
     * Generates a random mnemonic from the specified dictionary and word count
     *
     * @param {ParamsOfMnemonicFromRandom} params
     * @returns ResultOfMnemonicFromRandom
     */
    mnemonic_from_random(params) {
        return this.client.request('crypto.mnemonic_from_random', params);
    }
    /**
     * Generates mnemonic from pre-generated entropy
     *
     * @param {ParamsOfMnemonicFromEntropy} params
     * @returns ResultOfMnemonicFromEntropy
     */
    mnemonic_from_entropy(params) {
        return this.client.request('crypto.mnemonic_from_entropy', params);
    }
    /**
     * The phrase supplied will be checked for word length and validated according to the checksum specified in BIP0039.
     *
     * @param {ParamsOfMnemonicVerify} params
     * @returns ResultOfMnemonicVerify
     */
    mnemonic_verify(params) {
        return this.client.request('crypto.mnemonic_verify', params);
    }
    /**
     * Validates the seed phrase, generates master key and then derives the key pair from the master key and the specified path
     *
     * @param {ParamsOfMnemonicDeriveSignKeys} params
     * @returns KeyPair
     */
    mnemonic_derive_sign_keys(params) {
        return this.client.request('crypto.mnemonic_derive_sign_keys', params);
    }
    /**
     * Generates an extended master private key that will be the root for all the derived keys
     *
     * @param {ParamsOfHDKeyXPrvFromMnemonic} params
     * @returns ResultOfHDKeyXPrvFromMnemonic
     */
    hdkey_xprv_from_mnemonic(params) {
        return this.client.request('crypto.hdkey_xprv_from_mnemonic', params);
    }
    /**
     * Returns extended private key derived from the specified extended private key and child index
     *
     * @param {ParamsOfHDKeyDeriveFromXPrv} params
     * @returns ResultOfHDKeyDeriveFromXPrv
     */
    hdkey_derive_from_xprv(params) {
        return this.client.request('crypto.hdkey_derive_from_xprv', params);
    }
    /**
     * Derives the extended private key from the specified key and path
     *
     * @param {ParamsOfHDKeyDeriveFromXPrvPath} params
     * @returns ResultOfHDKeyDeriveFromXPrvPath
     */
    hdkey_derive_from_xprv_path(params) {
        return this.client.request('crypto.hdkey_derive_from_xprv_path', params);
    }
    /**
     * Extracts the private key from the serialized extended private key
     *
     * @param {ParamsOfHDKeySecretFromXPrv} params
     * @returns ResultOfHDKeySecretFromXPrv
     */
    hdkey_secret_from_xprv(params) {
        return this.client.request('crypto.hdkey_secret_from_xprv', params);
    }
    /**
     * Extracts the public key from the serialized extended private key
     *
     * @param {ParamsOfHDKeyPublicFromXPrv} params
     * @returns ResultOfHDKeyPublicFromXPrv
     */
    hdkey_public_from_xprv(params) {
        return this.client.request('crypto.hdkey_public_from_xprv', params);
    }
    /**
     * Performs symmetric `chacha20` encryption.
     *
     * @param {ParamsOfChaCha20} params
     * @returns ResultOfChaCha20
     */
    chacha20(params) {
        return this.client.request('crypto.chacha20', params);
    }
    /**
     * Register an application implemented signing box.
     * @returns RegisteredSigningBox
     */
    register_signing_box(obj) {
        return this.client.request('crypto.register_signing_box', undefined, (params, responseType) => {
            if (responseType === 3) {
                dispatchAppSigningBox(obj, params.request_data, params.app_request_id, this.client);
            }
            else if (responseType === 4) {
                dispatchAppSigningBox(obj, params, null, this.client);
            }
        });
    }
    /**
     * Creates a default signing box implementation.
     *
     * @param {KeyPair} params
     * @returns RegisteredSigningBox
     */
    get_signing_box(params) {
        return this.client.request('crypto.get_signing_box', params);
    }
    /**
     * Returns public key of signing key pair.
     *
     * @param {RegisteredSigningBox} params
     * @returns ResultOfSigningBoxGetPublicKey
     */
    signing_box_get_public_key(params) {
        return this.client.request('crypto.signing_box_get_public_key', params);
    }
    /**
     * Returns signed user data.
     *
     * @param {ParamsOfSigningBoxSign} params
     * @returns ResultOfSigningBoxSign
     */
    signing_box_sign(params) {
        return this.client.request('crypto.signing_box_sign', params);
    }
    /**
     * Removes signing box from SDK.
     *
     * @param {RegisteredSigningBox} params
     * @returns
     */
    remove_signing_box(params) {
        return this.client.request('crypto.remove_signing_box', params);
    }
}
exports.CryptoModule = CryptoModule;
// abi module
var AbiErrorCode;
(function (AbiErrorCode) {
    AbiErrorCode[AbiErrorCode["RequiredAddressMissingForEncodeMessage"] = 301] = "RequiredAddressMissingForEncodeMessage";
    AbiErrorCode[AbiErrorCode["RequiredCallSetMissingForEncodeMessage"] = 302] = "RequiredCallSetMissingForEncodeMessage";
    AbiErrorCode[AbiErrorCode["InvalidJson"] = 303] = "InvalidJson";
    AbiErrorCode[AbiErrorCode["InvalidMessage"] = 304] = "InvalidMessage";
    AbiErrorCode[AbiErrorCode["EncodeDeployMessageFailed"] = 305] = "EncodeDeployMessageFailed";
    AbiErrorCode[AbiErrorCode["EncodeRunMessageFailed"] = 306] = "EncodeRunMessageFailed";
    AbiErrorCode[AbiErrorCode["AttachSignatureFailed"] = 307] = "AttachSignatureFailed";
    AbiErrorCode[AbiErrorCode["InvalidTvcImage"] = 308] = "InvalidTvcImage";
    AbiErrorCode[AbiErrorCode["RequiredPublicKeyMissingForFunctionHeader"] = 309] = "RequiredPublicKeyMissingForFunctionHeader";
    AbiErrorCode[AbiErrorCode["InvalidSigner"] = 310] = "InvalidSigner";
    AbiErrorCode[AbiErrorCode["InvalidAbi"] = 311] = "InvalidAbi";
    AbiErrorCode[AbiErrorCode["InvalidFunctionId"] = 312] = "InvalidFunctionId";
})(AbiErrorCode = exports.AbiErrorCode || (exports.AbiErrorCode = {}));
function abiContract(value) {
    return {
        type: 'Contract',
        value,
    };
}
exports.abiContract = abiContract;
function abiJson(value) {
    return {
        type: 'Json',
        value,
    };
}
exports.abiJson = abiJson;
function abiHandle(value) {
    return {
        type: 'Handle',
        value,
    };
}
exports.abiHandle = abiHandle;
function abiSerialized(value) {
    return {
        type: 'Serialized',
        value,
    };
}
exports.abiSerialized = abiSerialized;
function signerNone() {
    return {
        type: 'None',
    };
}
exports.signerNone = signerNone;
function signerExternal(public_key) {
    return {
        type: 'External',
        public_key,
    };
}
exports.signerExternal = signerExternal;
function signerKeys(keys) {
    return {
        type: 'Keys',
        keys,
    };
}
exports.signerKeys = signerKeys;
function signerSigningBox(handle) {
    return {
        type: 'SigningBox',
        handle,
    };
}
exports.signerSigningBox = signerSigningBox;
var MessageBodyType;
(function (MessageBodyType) {
    MessageBodyType["Input"] = "Input";
    MessageBodyType["Output"] = "Output";
    MessageBodyType["InternalOutput"] = "InternalOutput";
    MessageBodyType["Event"] = "Event";
})(MessageBodyType = exports.MessageBodyType || (exports.MessageBodyType = {}));
function stateInitSourceMessage(source) {
    return {
        type: 'Message',
        source,
    };
}
exports.stateInitSourceMessage = stateInitSourceMessage;
function stateInitSourceStateInit(code, data, library) {
    return {
        type: 'StateInit',
        code,
        data,
        library,
    };
}
exports.stateInitSourceStateInit = stateInitSourceStateInit;
function stateInitSourceTvc(tvc, public_key, init_params) {
    return {
        type: 'Tvc',
        tvc,
        public_key,
        init_params,
    };
}
exports.stateInitSourceTvc = stateInitSourceTvc;
function messageSourceEncoded(message, abi) {
    return {
        type: 'Encoded',
        message,
        abi,
    };
}
exports.messageSourceEncoded = messageSourceEncoded;
function messageSourceEncodingParams(params) {
    return Object.assign({ type: 'EncodingParams' }, params);
}
exports.messageSourceEncodingParams = messageSourceEncodingParams;
/**
 * Provides message encoding and decoding according to the ABI specification.
 */
class AbiModule {
    constructor(client) {
        this.client = client;
    }
    /**
     * Encodes message body according to ABI function call.
     *
     * @param {ParamsOfEncodeMessageBody} params
     * @returns ResultOfEncodeMessageBody
     */
    encode_message_body(params) {
        return this.client.request('abi.encode_message_body', params);
    }
    /**
     *
     * @param {ParamsOfAttachSignatureToMessageBody} params
     * @returns ResultOfAttachSignatureToMessageBody
     */
    attach_signature_to_message_body(params) {
        return this.client.request('abi.attach_signature_to_message_body', params);
    }
    /**
     * Encodes an ABI-compatible message
     *
     * @remarks
     * Allows to encode deploy and function call messages,
     * both signed and unsigned.
     *
     * Use cases include messages of any possible type:
     * - deploy with initial function call (i.e. `constructor` or any other function that is used for some kind
     * of initialization);
     * - deploy without initial function call;
     * - signed/unsigned + data for signing.
     *
     * `Signer` defines how the message should or shouldn't be signed:
     *
     * `Signer::None` creates an unsigned message. This may be needed in case of some public methods,
     * that do not require authorization by pubkey.
     *
     * `Signer::External` takes public key and returns `data_to_sign` for later signing.
     * Use `attach_signature` method with the result signature to get the signed message.
     *
     * `Signer::Keys` creates a signed message with provided key pair.
     *
     * [SOON] `Signer::SigningBox` Allows using a special interface to implement signing
     * without private key disclosure to SDK. For instance, in case of using a cold wallet or HSM,
     * when application calls some API to sign data.
     *
     * There is an optional public key can be provided in deploy set in order to substitute one
     * in TVM file.
     *
     * Public key resolving priority:
     * 1. Public key from deploy set.
     * 2. Public key, specified in TVM file.
     * 3. Public key, provided by signer.
     *
     * @param {ParamsOfEncodeMessage} params
     * @returns ResultOfEncodeMessage
     */
    encode_message(params) {
        return this.client.request('abi.encode_message', params);
    }
    /**
     * Encodes an internal ABI-compatible message
     *
     * @remarks
     * Allows to encode deploy and function call messages.
     *
     * Use cases include messages of any possible type:
     * - deploy with initial function call (i.e. `constructor` or any other function that is used for some kind
     * of initialization);
     * - deploy without initial function call;
     * - simple function call
     *
     * There is an optional public key can be provided in deploy set in order to substitute one
     * in TVM file.
     *
     * Public key resolving priority:
     * 1. Public key from deploy set.
     * 2. Public key, specified in TVM file.
     *
     * @param {ParamsOfEncodeInternalMessage} params
     * @returns ResultOfEncodeInternalMessage
     */
    encode_internal_message(params) {
        return this.client.request('abi.encode_internal_message', params);
    }
    /**
     * Combines `hex`-encoded `signature` with `base64`-encoded `unsigned_message`. Returns signed message encoded in `base64`.
     *
     * @param {ParamsOfAttachSignature} params
     * @returns ResultOfAttachSignature
     */
    attach_signature(params) {
        return this.client.request('abi.attach_signature', params);
    }
    /**
     * Decodes message body using provided message BOC and ABI.
     *
     * @param {ParamsOfDecodeMessage} params
     * @returns DecodedMessageBody
     */
    decode_message(params) {
        return this.client.request('abi.decode_message', params);
    }
    /**
     * Decodes message body using provided body BOC and ABI.
     *
     * @param {ParamsOfDecodeMessageBody} params
     * @returns DecodedMessageBody
     */
    decode_message_body(params) {
        return this.client.request('abi.decode_message_body', params);
    }
    /**
     * Creates account state BOC
     *
     * @remarks
     * Creates account state provided with one of these sets of data :
     * 1. BOC of code, BOC of data, BOC of library
     * 2. TVC (string in `base64`), keys, init params
     *
     * @param {ParamsOfEncodeAccount} params
     * @returns ResultOfEncodeAccount
     */
    encode_account(params) {
        return this.client.request('abi.encode_account', params);
    }
}
exports.AbiModule = AbiModule;
function bocCacheTypePinned(pin) {
    return {
        type: 'Pinned',
        pin,
    };
}
exports.bocCacheTypePinned = bocCacheTypePinned;
function bocCacheTypeUnpinned() {
    return {
        type: 'Unpinned',
    };
}
exports.bocCacheTypeUnpinned = bocCacheTypeUnpinned;
var BocErrorCode;
(function (BocErrorCode) {
    BocErrorCode[BocErrorCode["InvalidBoc"] = 201] = "InvalidBoc";
    BocErrorCode[BocErrorCode["SerializationError"] = 202] = "SerializationError";
    BocErrorCode[BocErrorCode["InappropriateBlock"] = 203] = "InappropriateBlock";
    BocErrorCode[BocErrorCode["MissingSourceBoc"] = 204] = "MissingSourceBoc";
    BocErrorCode[BocErrorCode["InsufficientCacheSize"] = 205] = "InsufficientCacheSize";
    BocErrorCode[BocErrorCode["BocRefNotFound"] = 206] = "BocRefNotFound";
    BocErrorCode[BocErrorCode["InvalidBocRef"] = 207] = "InvalidBocRef";
})(BocErrorCode = exports.BocErrorCode || (exports.BocErrorCode = {}));
function builderOpInteger(size, value) {
    return {
        type: 'Integer',
        size,
        value,
    };
}
exports.builderOpInteger = builderOpInteger;
function builderOpBitString(value) {
    return {
        type: 'BitString',
        value,
    };
}
exports.builderOpBitString = builderOpBitString;
function builderOpCell(builder) {
    return {
        type: 'Cell',
        builder,
    };
}
exports.builderOpCell = builderOpCell;
function builderOpCellBoc(boc) {
    return {
        type: 'CellBoc',
        boc,
    };
}
exports.builderOpCellBoc = builderOpCellBoc;
/**
 * BOC manipulation module.
 */
class BocModule {
    constructor(client) {
        this.client = client;
    }
    /**
     * Parses message boc into a JSON
     *
     * @remarks
     * JSON structure is compatible with GraphQL API message object
     *
     * @param {ParamsOfParse} params
     * @returns ResultOfParse
     */
    parse_message(params) {
        return this.client.request('boc.parse_message', params);
    }
    /**
     * Parses transaction boc into a JSON
     *
     * @remarks
     * JSON structure is compatible with GraphQL API transaction object
     *
     * @param {ParamsOfParse} params
     * @returns ResultOfParse
     */
    parse_transaction(params) {
        return this.client.request('boc.parse_transaction', params);
    }
    /**
     * Parses account boc into a JSON
     *
     * @remarks
     * JSON structure is compatible with GraphQL API account object
     *
     * @param {ParamsOfParse} params
     * @returns ResultOfParse
     */
    parse_account(params) {
        return this.client.request('boc.parse_account', params);
    }
    /**
     * Parses block boc into a JSON
     *
     * @remarks
     * JSON structure is compatible with GraphQL API block object
     *
     * @param {ParamsOfParse} params
     * @returns ResultOfParse
     */
    parse_block(params) {
        return this.client.request('boc.parse_block', params);
    }
    /**
     * Parses shardstate boc into a JSON
     *
     * @remarks
     * JSON structure is compatible with GraphQL API shardstate object
     *
     * @param {ParamsOfParseShardstate} params
     * @returns ResultOfParse
     */
    parse_shardstate(params) {
        return this.client.request('boc.parse_shardstate', params);
    }
    /**
     * Extract blockchain configuration from key block and also from zerostate.
     *
     * @param {ParamsOfGetBlockchainConfig} params
     * @returns ResultOfGetBlockchainConfig
     */
    get_blockchain_config(params) {
        return this.client.request('boc.get_blockchain_config', params);
    }
    /**
     * Calculates BOC root hash
     *
     * @param {ParamsOfGetBocHash} params
     * @returns ResultOfGetBocHash
     */
    get_boc_hash(params) {
        return this.client.request('boc.get_boc_hash', params);
    }
    /**
     * Extracts code from TVC contract image
     *
     * @param {ParamsOfGetCodeFromTvc} params
     * @returns ResultOfGetCodeFromTvc
     */
    get_code_from_tvc(params) {
        return this.client.request('boc.get_code_from_tvc', params);
    }
    /**
     * Get BOC from cache
     *
     * @param {ParamsOfBocCacheGet} params
     * @returns ResultOfBocCacheGet
     */
    cache_get(params) {
        return this.client.request('boc.cache_get', params);
    }
    /**
     * Save BOC into cache
     *
     * @param {ParamsOfBocCacheSet} params
     * @returns ResultOfBocCacheSet
     */
    cache_set(params) {
        return this.client.request('boc.cache_set', params);
    }
    /**
     * Unpin BOCs with specified pin.
     *
     * @remarks
     * BOCs which don't have another pins will be removed from cache
     *
     * @param {ParamsOfBocCacheUnpin} params
     * @returns
     */
    cache_unpin(params) {
        return this.client.request('boc.cache_unpin', params);
    }
    /**
     * Encodes BOC from builder operations.
     *
     * @param {ParamsOfEncodeBoc} params
     * @returns ResultOfEncodeBoc
     */
    encode_boc(params) {
        return this.client.request('boc.encode_boc', params);
    }
}
exports.BocModule = BocModule;
// processing module
var ProcessingErrorCode;
(function (ProcessingErrorCode) {
    ProcessingErrorCode[ProcessingErrorCode["MessageAlreadyExpired"] = 501] = "MessageAlreadyExpired";
    ProcessingErrorCode[ProcessingErrorCode["MessageHasNotDestinationAddress"] = 502] = "MessageHasNotDestinationAddress";
    ProcessingErrorCode[ProcessingErrorCode["CanNotBuildMessageCell"] = 503] = "CanNotBuildMessageCell";
    ProcessingErrorCode[ProcessingErrorCode["FetchBlockFailed"] = 504] = "FetchBlockFailed";
    ProcessingErrorCode[ProcessingErrorCode["SendMessageFailed"] = 505] = "SendMessageFailed";
    ProcessingErrorCode[ProcessingErrorCode["InvalidMessageBoc"] = 506] = "InvalidMessageBoc";
    ProcessingErrorCode[ProcessingErrorCode["MessageExpired"] = 507] = "MessageExpired";
    ProcessingErrorCode[ProcessingErrorCode["TransactionWaitTimeout"] = 508] = "TransactionWaitTimeout";
    ProcessingErrorCode[ProcessingErrorCode["InvalidBlockReceived"] = 509] = "InvalidBlockReceived";
    ProcessingErrorCode[ProcessingErrorCode["CanNotCheckBlockShard"] = 510] = "CanNotCheckBlockShard";
    ProcessingErrorCode[ProcessingErrorCode["BlockNotFound"] = 511] = "BlockNotFound";
    ProcessingErrorCode[ProcessingErrorCode["InvalidData"] = 512] = "InvalidData";
    ProcessingErrorCode[ProcessingErrorCode["ExternalSignerMustNotBeUsed"] = 513] = "ExternalSignerMustNotBeUsed";
})(ProcessingErrorCode = exports.ProcessingErrorCode || (exports.ProcessingErrorCode = {}));
function processingEventWillFetchFirstBlock() {
    return {
        type: 'WillFetchFirstBlock',
    };
}
exports.processingEventWillFetchFirstBlock = processingEventWillFetchFirstBlock;
function processingEventFetchFirstBlockFailed(error) {
    return {
        type: 'FetchFirstBlockFailed',
        error,
    };
}
exports.processingEventFetchFirstBlockFailed = processingEventFetchFirstBlockFailed;
function processingEventWillSend(shard_block_id, message_id, message) {
    return {
        type: 'WillSend',
        shard_block_id,
        message_id,
        message,
    };
}
exports.processingEventWillSend = processingEventWillSend;
function processingEventDidSend(shard_block_id, message_id, message) {
    return {
        type: 'DidSend',
        shard_block_id,
        message_id,
        message,
    };
}
exports.processingEventDidSend = processingEventDidSend;
function processingEventSendFailed(shard_block_id, message_id, message, error) {
    return {
        type: 'SendFailed',
        shard_block_id,
        message_id,
        message,
        error,
    };
}
exports.processingEventSendFailed = processingEventSendFailed;
function processingEventWillFetchNextBlock(shard_block_id, message_id, message) {
    return {
        type: 'WillFetchNextBlock',
        shard_block_id,
        message_id,
        message,
    };
}
exports.processingEventWillFetchNextBlock = processingEventWillFetchNextBlock;
function processingEventFetchNextBlockFailed(shard_block_id, message_id, message, error) {
    return {
        type: 'FetchNextBlockFailed',
        shard_block_id,
        message_id,
        message,
        error,
    };
}
exports.processingEventFetchNextBlockFailed = processingEventFetchNextBlockFailed;
function processingEventMessageExpired(message_id, message, error) {
    return {
        type: 'MessageExpired',
        message_id,
        message,
        error,
    };
}
exports.processingEventMessageExpired = processingEventMessageExpired;
/**
 * Message processing module.
 *
 * @remarks
 * This module incorporates functions related to complex message
 * processing scenarios.
 */
class ProcessingModule {
    constructor(client) {
        this.client = client;
    }
    /**
     * Sends message to the network
     *
     * @remarks
     * Sends message to the network and returns the last generated shard block of the destination account
     * before the message was sent. It will be required later for message processing.
     *
     * @param {ParamsOfSendMessage} params
     * @returns ResultOfSendMessage
     */
    send_message(params, responseHandler) {
        return this.client.request('processing.send_message', params, responseHandler);
    }
    /**
     * Performs monitoring of the network for the result transaction of the external inbound message processing.
     *
     * @remarks
     * `send_events` enables intermediate events, such as `WillFetchNextBlock`,
     * `FetchNextBlockFailed` that may be useful for logging of new shard blocks creation
     * during message processing.
     *
     * Note, that presence of the `abi` parameter is critical for ABI
     * compliant contracts. Message processing uses drastically
     * different strategy for processing message for contracts which
     * ABI includes "expire" header.
     *
     * When the ABI header `expire` is present, the processing uses
     * `message expiration` strategy:
     * - The maximum block gen time is set to
     *   `message_expiration_timeout + transaction_wait_timeout`.
     * - When maximum block gen time is reached, the processing will
     *   be finished with `MessageExpired` error.
     *
     * When the ABI header `expire` isn't present or `abi` parameter
     * isn't specified, the processing uses `transaction waiting`
     * strategy:
     * - The maximum block gen time is set to
     *   `now() + transaction_wait_timeout`.
     *
     * - If maximum block gen time is reached and no result transaction is found,
     * the processing will exit with an error.
     *
     * @param {ParamsOfWaitForTransaction} params
     * @returns ResultOfProcessMessage
     */
    wait_for_transaction(params, responseHandler) {
        return this.client.request('processing.wait_for_transaction', params, responseHandler);
    }
    /**
     * Creates message, sends it to the network and monitors its processing.
     *
     * @remarks
     * Creates ABI-compatible message,
     * sends it to the network and monitors for the result transaction.
     * Decodes the output messages' bodies.
     *
     * If contract's ABI includes "expire" header, then
     * SDK implements retries in case of unsuccessful message delivery within the expiration
     * timeout: SDK recreates the message, sends it and processes it again.
     *
     * The intermediate events, such as `WillFetchFirstBlock`, `WillSend`, `DidSend`,
     * `WillFetchNextBlock`, etc - are switched on/off by `send_events` flag
     * and logged into the supplied callback function.
     *
     * The retry configuration parameters are defined in the client's `NetworkConfig` and `AbiConfig`.
     *
     * If contract's ABI does not include "expire" header
     * then, if no transaction is found within the network timeout (see config parameter ), exits with error.
     *
     * @param {ParamsOfProcessMessage} params
     * @returns ResultOfProcessMessage
     */
    process_message(params, responseHandler) {
        return this.client.request('processing.process_message', params, responseHandler);
    }
}
exports.ProcessingModule = ProcessingModule;
function addressStringFormatAccountId() {
    return {
        type: 'AccountId',
    };
}
exports.addressStringFormatAccountId = addressStringFormatAccountId;
function addressStringFormatHex() {
    return {
        type: 'Hex',
    };
}
exports.addressStringFormatHex = addressStringFormatHex;
function addressStringFormatBase64(url, test, bounce) {
    return {
        type: 'Base64',
        url,
        test,
        bounce,
    };
}
exports.addressStringFormatBase64 = addressStringFormatBase64;
/**
 * Misc utility Functions.
 */
class UtilsModule {
    constructor(client) {
        this.client = client;
    }
    /**
     * Converts address from any TON format to any TON format
     *
     * @param {ParamsOfConvertAddress} params
     * @returns ResultOfConvertAddress
     */
    convert_address(params) {
        return this.client.request('utils.convert_address', params);
    }
}
exports.UtilsModule = UtilsModule;
// tvm module
var TvmErrorCode;
(function (TvmErrorCode) {
    TvmErrorCode[TvmErrorCode["CanNotReadTransaction"] = 401] = "CanNotReadTransaction";
    TvmErrorCode[TvmErrorCode["CanNotReadBlockchainConfig"] = 402] = "CanNotReadBlockchainConfig";
    TvmErrorCode[TvmErrorCode["TransactionAborted"] = 403] = "TransactionAborted";
    TvmErrorCode[TvmErrorCode["InternalError"] = 404] = "InternalError";
    TvmErrorCode[TvmErrorCode["ActionPhaseFailed"] = 405] = "ActionPhaseFailed";
    TvmErrorCode[TvmErrorCode["AccountCodeMissing"] = 406] = "AccountCodeMissing";
    TvmErrorCode[TvmErrorCode["LowBalance"] = 407] = "LowBalance";
    TvmErrorCode[TvmErrorCode["AccountFrozenOrDeleted"] = 408] = "AccountFrozenOrDeleted";
    TvmErrorCode[TvmErrorCode["AccountMissing"] = 409] = "AccountMissing";
    TvmErrorCode[TvmErrorCode["UnknownExecutionError"] = 410] = "UnknownExecutionError";
    TvmErrorCode[TvmErrorCode["InvalidInputStack"] = 411] = "InvalidInputStack";
    TvmErrorCode[TvmErrorCode["InvalidAccountBoc"] = 412] = "InvalidAccountBoc";
    TvmErrorCode[TvmErrorCode["InvalidMessageType"] = 413] = "InvalidMessageType";
    TvmErrorCode[TvmErrorCode["ContractExecutionError"] = 414] = "ContractExecutionError";
})(TvmErrorCode = exports.TvmErrorCode || (exports.TvmErrorCode = {}));
function accountForExecutorNone() {
    return {
        type: 'None',
    };
}
exports.accountForExecutorNone = accountForExecutorNone;
function accountForExecutorUninit() {
    return {
        type: 'Uninit',
    };
}
exports.accountForExecutorUninit = accountForExecutorUninit;
function accountForExecutorAccount(boc, unlimited_balance) {
    return {
        type: 'Account',
        boc,
        unlimited_balance,
    };
}
exports.accountForExecutorAccount = accountForExecutorAccount;
/**
 */
class TvmModule {
    constructor(client) {
        this.client = client;
    }
    /**
     * Emulates all the phases of contract execution locally
     *
     * @remarks
     * Performs all the phases of contract execution on Transaction Executor -
     * the same component that is used on Validator Nodes.
     *
     * Can be used for contract debugginh, to find out the reason why message was not delivered successfully
     *  - because Validators just throw away the failed external inbound messages, here you can catch them.
     *
     * Another use case is to estimate fees for message execution. Set  `AccountForExecutor::Account.unlimited_balance`
     * to `true` so that emulation will not depend on the actual balance.
     *
     * One more use case - you can produce the sequence of operations,
     * thus emulating the multiple contract calls locally.
     * And so on.
     *
     * To get the account BOC (bag of cells) - use `net.query` method to download it from GraphQL API
     * (field `boc` of `account`) or generate it with `abi.encode_account` method.
     * To get the message BOC - use `abi.encode_message` or prepare it any other way, for instance, with FIFT script.
     *
     * If you need this emulation to be as precise as possible then specify `ParamsOfRunExecutor` parameter.
     * If you need to see the aborted transaction as a result, not as an error, set `skip_transaction_check` to `true`.
     *
     * @param {ParamsOfRunExecutor} params
     * @returns ResultOfRunExecutor
     */
    run_executor(params) {
        return this.client.request('tvm.run_executor', params);
    }
    /**
     * Executes get-methods of ABI-compatible contracts
     *
     * @remarks
     * Performs only a part of compute phase of transaction execution
     * that is used to run get-methods of ABI-compatible contracts.
     *
     * If you try to run get-methods with `run_executor` you will get an error, because it checks ACCEPT and exits
     * if there is none, which is actually true for get-methods.
     *
     *  To get the account BOC (bag of cells) - use `net.query` method to download it from GraphQL API
     * (field `boc` of `account`) or generate it with `abi.encode_account method`.
     * To get the message BOC - use `abi.encode_message` or prepare it any other way, for instance, with FIFT script.
     *
     * Attention! Updated account state is produces as well, but only
     * `account_state.storage.state.data`  part of the BOC is updated.
     *
     * @param {ParamsOfRunTvm} params
     * @returns ResultOfRunTvm
     */
    run_tvm(params) {
        return this.client.request('tvm.run_tvm', params);
    }
    /**
     * Executes a get-method of FIFT contract
     *
     * @remarks
     * Executes a get-method of FIFT contract that fulfills the smc-guidelines https://test.ton.org/smc-guidelines.txt
     * and returns the result data from TVM's stack
     *
     * @param {ParamsOfRunGet} params
     * @returns ResultOfRunGet
     */
    run_get(params) {
        return this.client.request('tvm.run_get', params);
    }
}
exports.TvmModule = TvmModule;
// net module
var NetErrorCode;
(function (NetErrorCode) {
    NetErrorCode[NetErrorCode["QueryFailed"] = 601] = "QueryFailed";
    NetErrorCode[NetErrorCode["SubscribeFailed"] = 602] = "SubscribeFailed";
    NetErrorCode[NetErrorCode["WaitForFailed"] = 603] = "WaitForFailed";
    NetErrorCode[NetErrorCode["GetSubscriptionResultFailed"] = 604] = "GetSubscriptionResultFailed";
    NetErrorCode[NetErrorCode["InvalidServerResponse"] = 605] = "InvalidServerResponse";
    NetErrorCode[NetErrorCode["ClockOutOfSync"] = 606] = "ClockOutOfSync";
    NetErrorCode[NetErrorCode["WaitForTimeout"] = 607] = "WaitForTimeout";
    NetErrorCode[NetErrorCode["GraphqlError"] = 608] = "GraphqlError";
    NetErrorCode[NetErrorCode["NetworkModuleSuspended"] = 609] = "NetworkModuleSuspended";
    NetErrorCode[NetErrorCode["WebsocketDisconnected"] = 610] = "WebsocketDisconnected";
    NetErrorCode[NetErrorCode["NotSupported"] = 611] = "NotSupported";
    NetErrorCode[NetErrorCode["NoEndpointsProvided"] = 612] = "NoEndpointsProvided";
    NetErrorCode[NetErrorCode["GraphqlWebsocketInitError"] = 613] = "GraphqlWebsocketInitError";
    NetErrorCode[NetErrorCode["NetworkModuleResumed"] = 614] = "NetworkModuleResumed";
})(NetErrorCode = exports.NetErrorCode || (exports.NetErrorCode = {}));
var SortDirection;
(function (SortDirection) {
    SortDirection["ASC"] = "ASC";
    SortDirection["DESC"] = "DESC";
})(SortDirection = exports.SortDirection || (exports.SortDirection = {}));
function paramsOfQueryOperationQueryCollection(params) {
    return Object.assign({ type: 'QueryCollection' }, params);
}
exports.paramsOfQueryOperationQueryCollection = paramsOfQueryOperationQueryCollection;
function paramsOfQueryOperationWaitForCollection(params) {
    return Object.assign({ type: 'WaitForCollection' }, params);
}
exports.paramsOfQueryOperationWaitForCollection = paramsOfQueryOperationWaitForCollection;
function paramsOfQueryOperationAggregateCollection(params) {
    return Object.assign({ type: 'AggregateCollection' }, params);
}
exports.paramsOfQueryOperationAggregateCollection = paramsOfQueryOperationAggregateCollection;
var AggregationFn;
(function (AggregationFn) {
    AggregationFn["COUNT"] = "COUNT";
    AggregationFn["MIN"] = "MIN";
    AggregationFn["MAX"] = "MAX";
    AggregationFn["SUM"] = "SUM";
    AggregationFn["AVERAGE"] = "AVERAGE";
})(AggregationFn = exports.AggregationFn || (exports.AggregationFn = {}));
/**
 * Network access.
 */
class NetModule {
    constructor(client) {
        this.client = client;
    }
    /**
     * Performs DAppServer GraphQL query.
     *
     * @param {ParamsOfQuery} params
     * @returns ResultOfQuery
     */
    query(params) {
        return this.client.request('net.query', params);
    }
    /**
     * Performs multiple queries per single fetch.
     *
     * @param {ParamsOfBatchQuery} params
     * @returns ResultOfBatchQuery
     */
    batch_query(params) {
        return this.client.request('net.batch_query', params);
    }
    /**
     * Queries collection data
     *
     * @remarks
     * Queries data that satisfies the `filter` conditions,
     * limits the number of returned records and orders them.
     * The projection fields are limited to `result` fields
     *
     * @param {ParamsOfQueryCollection} params
     * @returns ResultOfQueryCollection
     */
    query_collection(params) {
        return this.client.request('net.query_collection', params);
    }
    /**
     * Aggregates collection data.
     *
     * @remarks
     * Aggregates values from the specified `fields` for records
     * that satisfies the `filter` conditions,
     *
     * @param {ParamsOfAggregateCollection} params
     * @returns ResultOfAggregateCollection
     */
    aggregate_collection(params) {
        return this.client.request('net.aggregate_collection', params);
    }
    /**
     * Returns an object that fulfills the conditions or waits for its appearance
     *
     * @remarks
     * Triggers only once.
     * If object that satisfies the `filter` conditions
     * already exists - returns it immediately.
     * If not - waits for insert/update of data within the specified `timeout`,
     * and returns it.
     * The projection fields are limited to `result` fields
     *
     * @param {ParamsOfWaitForCollection} params
     * @returns ResultOfWaitForCollection
     */
    wait_for_collection(params) {
        return this.client.request('net.wait_for_collection', params);
    }
    /**
     * Cancels a subscription
     *
     * @remarks
     * Cancels a subscription specified by its handle.
     *
     * @param {ResultOfSubscribeCollection} params
     * @returns
     */
    unsubscribe(params) {
        return this.client.request('net.unsubscribe', params);
    }
    /**
     * Creates a subscription
     *
     * @remarks
     * Triggers for each insert/update of data that satisfies
     * the `filter` conditions.
     * The projection fields are limited to `result` fields.
     *
     * The subscription is a persistent communication channel between
     * client and Free TON Network.
     * All changes in the blockchain will be reflected in realtime.
     * Changes means inserts and updates of the blockchain entities.
     *
     * ### Important Notes on Subscriptions
     *
     * Unfortunately sometimes the connection with the network brakes down.
     * In this situation the library attempts to reconnect to the network.
     * This reconnection sequence can take significant time.
     * All of this time the client is disconnected from the network.
     *
     * Bad news is that all blockchain changes that happened while
     * the client was disconnected are lost.
     *
     * Good news is that the client report errors to the callback when
     * it loses and resumes connection.
     *
     * So, if the lost changes are important to the application then
     * the application must handle these error reports.
     *
     * Library reports errors with `responseType` == 101
     * and the error object passed via `params`.
     *
     * When the library has successfully reconnected
     * the application receives callback with
     * `responseType` == 101 and `params.code` == 614 (NetworkModuleResumed).
     *
     * Application can use several ways to handle this situation:
     * - If application monitors changes for the single blockchain
     * object (for example specific account):  application
     * can perform a query for this object and handle actual data as a
     * regular data from the subscription.
     * - If application monitors sequence of some blockchain objects
     * (for example transactions of the specific account): application must
     * refresh all cached (or visible to user) lists where this sequences presents.
     *
     * @param {ParamsOfSubscribeCollection} params
     * @returns ResultOfSubscribeCollection
     */
    subscribe_collection(params, responseHandler) {
        return this.client.request('net.subscribe_collection', params, responseHandler);
    }
    /**
     * Suspends network module to stop any network activity
     * @returns
     */
    suspend() {
        return this.client.request('net.suspend');
    }
    /**
     * Resumes network module to enable network activity
     * @returns
     */
    resume() {
        return this.client.request('net.resume');
    }
    /**
     * Returns ID of the last block in a specified account shard
     *
     * @param {ParamsOfFindLastShardBlock} params
     * @returns ResultOfFindLastShardBlock
     */
    find_last_shard_block(params) {
        return this.client.request('net.find_last_shard_block', params);
    }
    /**
     * Requests the list of alternative endpoints from server
     * @returns EndpointsSet
     */
    fetch_endpoints() {
        return this.client.request('net.fetch_endpoints');
    }
    /**
     * Sets the list of endpoints to use on reinit
     *
     * @param {EndpointsSet} params
     * @returns
     */
    set_endpoints(params) {
        return this.client.request('net.set_endpoints', params);
    }
}
exports.NetModule = NetModule;
// debot module
var DebotErrorCode;
(function (DebotErrorCode) {
    DebotErrorCode[DebotErrorCode["DebotStartFailed"] = 801] = "DebotStartFailed";
    DebotErrorCode[DebotErrorCode["DebotFetchFailed"] = 802] = "DebotFetchFailed";
    DebotErrorCode[DebotErrorCode["DebotExecutionFailed"] = 803] = "DebotExecutionFailed";
    DebotErrorCode[DebotErrorCode["DebotInvalidHandle"] = 804] = "DebotInvalidHandle";
    DebotErrorCode[DebotErrorCode["DebotInvalidJsonParams"] = 805] = "DebotInvalidJsonParams";
    DebotErrorCode[DebotErrorCode["DebotInvalidFunctionId"] = 806] = "DebotInvalidFunctionId";
    DebotErrorCode[DebotErrorCode["DebotInvalidAbi"] = 807] = "DebotInvalidAbi";
    DebotErrorCode[DebotErrorCode["DebotGetMethodFailed"] = 808] = "DebotGetMethodFailed";
    DebotErrorCode[DebotErrorCode["DebotInvalidMsg"] = 809] = "DebotInvalidMsg";
    DebotErrorCode[DebotErrorCode["DebotExternalCallFailed"] = 810] = "DebotExternalCallFailed";
})(DebotErrorCode = exports.DebotErrorCode || (exports.DebotErrorCode = {}));
function paramsOfAppDebotBrowserLog(msg) {
    return {
        type: 'Log',
        msg,
    };
}
exports.paramsOfAppDebotBrowserLog = paramsOfAppDebotBrowserLog;
function paramsOfAppDebotBrowserSwitch(context_id) {
    return {
        type: 'Switch',
        context_id,
    };
}
exports.paramsOfAppDebotBrowserSwitch = paramsOfAppDebotBrowserSwitch;
function paramsOfAppDebotBrowserSwitchCompleted() {
    return {
        type: 'SwitchCompleted',
    };
}
exports.paramsOfAppDebotBrowserSwitchCompleted = paramsOfAppDebotBrowserSwitchCompleted;
function paramsOfAppDebotBrowserShowAction(action) {
    return {
        type: 'ShowAction',
        action,
    };
}
exports.paramsOfAppDebotBrowserShowAction = paramsOfAppDebotBrowserShowAction;
function paramsOfAppDebotBrowserInput(prompt) {
    return {
        type: 'Input',
        prompt,
    };
}
exports.paramsOfAppDebotBrowserInput = paramsOfAppDebotBrowserInput;
function paramsOfAppDebotBrowserGetSigningBox() {
    return {
        type: 'GetSigningBox',
    };
}
exports.paramsOfAppDebotBrowserGetSigningBox = paramsOfAppDebotBrowserGetSigningBox;
function paramsOfAppDebotBrowserInvokeDebot(debot_addr, action) {
    return {
        type: 'InvokeDebot',
        debot_addr,
        action,
    };
}
exports.paramsOfAppDebotBrowserInvokeDebot = paramsOfAppDebotBrowserInvokeDebot;
function paramsOfAppDebotBrowserSend(message) {
    return {
        type: 'Send',
        message,
    };
}
exports.paramsOfAppDebotBrowserSend = paramsOfAppDebotBrowserSend;
function resultOfAppDebotBrowserInput(value) {
    return {
        type: 'Input',
        value,
    };
}
exports.resultOfAppDebotBrowserInput = resultOfAppDebotBrowserInput;
function resultOfAppDebotBrowserGetSigningBox(signing_box) {
    return {
        type: 'GetSigningBox',
        signing_box,
    };
}
exports.resultOfAppDebotBrowserGetSigningBox = resultOfAppDebotBrowserGetSigningBox;
function resultOfAppDebotBrowserInvokeDebot() {
    return {
        type: 'InvokeDebot',
    };
}
exports.resultOfAppDebotBrowserInvokeDebot = resultOfAppDebotBrowserInvokeDebot;
function dispatchAppDebotBrowser(obj, params, app_request_id, client) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            let result = {};
            switch (params.type) {
                case 'Log':
                    obj.log(params);
                    break;
                case 'Switch':
                    obj.switch(params);
                    break;
                case 'SwitchCompleted':
                    obj.switch_completed();
                    break;
                case 'ShowAction':
                    obj.show_action(params);
                    break;
                case 'Input':
                    result = yield obj.input(params);
                    break;
                case 'GetSigningBox':
                    result = yield obj.get_signing_box();
                    break;
                case 'InvokeDebot':
                    yield obj.invoke_debot(params);
                    break;
                case 'Send':
                    obj.send(params);
                    break;
            }
            client.resolve_app_request(app_request_id, Object.assign({ type: params.type }, result));
        }
        catch (error) {
            client.reject_app_request(app_request_id, error);
        }
    });
}
/**
 * [UNSTABLE](UNSTABLE.md) Module for working with debot.
 */
class DebotModule {
    constructor(client) {
        this.client = client;
    }
    /**
     * [UNSTABLE](UNSTABLE.md) Starts an instance of debot.
     *
     * @remarks
     * Downloads debot smart contract from blockchain and switches it to
     * context zero.
     * Returns a debot handle which can be used later in `execute` function.
     * This function must be used by Debot Browser to start a dialog with debot.
     * While the function is executing, several Browser Callbacks can be called,
     * since the debot tries to display all actions from the context 0 to the user.
     *
     * # Remarks
     * `start` is equivalent to `fetch` + switch to context 0.
     *
     * @param {ParamsOfStart} params
     * @returns RegisteredDebot
     */
    start(params, obj) {
        return this.client.request('debot.start', params, (params, responseType) => {
            if (responseType === 3) {
                dispatchAppDebotBrowser(obj, params.request_data, params.app_request_id, this.client);
            }
            else if (responseType === 4) {
                dispatchAppDebotBrowser(obj, params, null, this.client);
            }
        });
    }
    /**
     * [UNSTABLE](UNSTABLE.md) Fetches debot from blockchain.
     *
     * @remarks
     * Downloads debot smart contract (code and data) from blockchain and creates
     * an instance of Debot Engine for it.
     *
     * # Remarks
     * It does not switch debot to context 0. Browser Callbacks are not called.
     *
     * @param {ParamsOfFetch} params
     * @returns RegisteredDebot
     */
    fetch(params, obj) {
        return this.client.request('debot.fetch', params, (params, responseType) => {
            if (responseType === 3) {
                dispatchAppDebotBrowser(obj, params.request_data, params.app_request_id, this.client);
            }
            else if (responseType === 4) {
                dispatchAppDebotBrowser(obj, params, null, this.client);
            }
        });
    }
    /**
     * [UNSTABLE](UNSTABLE.md) Executes debot action.
     *
     * @remarks
     * Calls debot engine referenced by debot handle to execute input action.
     * Calls Debot Browser Callbacks if needed.
     *
     * # Remarks
     * Chain of actions can be executed if input action generates a list of subactions.
     *
     * @param {ParamsOfExecute} params
     * @returns
     */
    execute(params) {
        return this.client.request('debot.execute', params);
    }
    /**
     * [UNSTABLE](UNSTABLE.md) Sends message to Debot.
     *
     * @remarks
     * Used by Debot Browser to send response on Dinterface call or from other Debots.
     *
     * @param {ParamsOfSend} params
     * @returns
     */
    send(params) {
        return this.client.request('debot.send', params);
    }
    /**
     * [UNSTABLE](UNSTABLE.md) Destroys debot handle.
     *
     * @remarks
     * Removes handle from Client Context and drops debot engine referenced by that handle.
     *
     * @param {RegisteredDebot} params
     * @returns
     */
    remove(params) {
        return this.client.request('debot.remove', params);
    }
}
exports.DebotModule = DebotModule;
//# sourceMappingURL=modules.js.map