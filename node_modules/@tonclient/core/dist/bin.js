"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.request = exports.destroyContext = exports.createContext = exports.useLibrary = exports.ResponseType = void 0;
const errors_1 = require("./errors");
var ResponseType;
(function (ResponseType) {
    ResponseType[ResponseType["Success"] = 0] = "Success";
    ResponseType[ResponseType["Error"] = 1] = "Error";
    ResponseType[ResponseType["Nop"] = 2] = "Nop";
    ResponseType[ResponseType["AppRequest"] = 3] = "AppRequest";
    ResponseType[ResponseType["AppNotify"] = 4] = "AppNotify";
    ResponseType[ResponseType["Custom"] = 100] = "Custom";
})(ResponseType = exports.ResponseType || (exports.ResponseType = {}));
let loading = null;
let loadError = null;
let library = null;
const requests = new Map();
let nextRequestId = 1;
let contextCount = 0;
let responseHandlerAssigned = false;
function checkResponseHandler() {
    const mustBeAssigned = (contextCount > 0) || (requests.size > 0);
    if (responseHandlerAssigned !== mustBeAssigned) {
        if (mustBeAssigned) {
            library === null || library === void 0 ? void 0 : library.setResponseHandler(handleLibraryResponse);
        }
        else {
            library === null || library === void 0 ? void 0 : library.setResponseHandler();
        }
        responseHandlerAssigned = mustBeAssigned;
    }
}
function useLibrary(loader) {
    loading = [];
    loader().then((lib, error) => {
        const saveLoading = loading;
        loading = null;
        if (lib) {
            library = lib;
            saveLoading === null || saveLoading === void 0 ? void 0 : saveLoading.forEach(x => x.resolve(lib));
        }
        else {
            loadError = error || null;
            saveLoading === null || saveLoading === void 0 ? void 0 : saveLoading.forEach(x => x.reject(error));
        }
    });
}
exports.useLibrary = useLibrary;
function createContext(config) {
    return __awaiter(this, void 0, void 0, function* () {
        const lib = library || (yield loadRequired());
        contextCount += 1;
        return parseResult(yield lib.createContext(JSON.stringify(config)));
    });
}
exports.createContext = createContext;
function destroyContext(context) {
    contextCount = Math.max(contextCount - 1, 0);
    checkResponseHandler();
    library === null || library === void 0 ? void 0 : library.destroyContext(context);
}
exports.destroyContext = destroyContext;
function request(context, functionName, functionParams, responseHandler) {
    return __awaiter(this, void 0, void 0, function* () {
        const lib = library || (yield loadRequired());
        return new Promise((resolve, reject) => {
            const request = {
                resolve,
                reject,
                responseHandler,
            };
            const requestId = generateRequestId();
            requests.set(requestId, request);
            checkResponseHandler();
            const paramsJson = (functionParams === undefined) || (functionParams === null)
                ? ""
                : JSON.stringify(functionParams);
            lib.sendRequest(context, requestId, functionName, paramsJson);
        });
    });
}
exports.request = request;
function loadRequired() {
    if (library !== null) {
        return Promise.resolve(library);
    }
    if (loadError !== null) {
        return Promise.reject(loadError);
    }
    if (loading === null) {
        return Promise.reject(new errors_1.TonClientError(1, "TON Client binary library isn't set."));
    }
    return new Promise((resolve, reject) => {
        loading === null || loading === void 0 ? void 0 : loading.push({
            resolve,
            reject,
        });
    });
}
function generateRequestId() {
    const id = nextRequestId;
    do {
        nextRequestId += 1;
        if (nextRequestId >= Number.MAX_SAFE_INTEGER) {
            nextRequestId = 1;
        }
    } while (requests.has(nextRequestId));
    return id;
}
function handleLibraryResponse(requestId, paramsJson, responseType, finished) {
    const request = requests.get(requestId);
    if (!request) {
        return;
    }
    if (finished) {
        requests.delete(requestId);
        checkResponseHandler();
    }
    const params = paramsJson !== "" ? JSON.parse(paramsJson) : undefined;
    switch (responseType) {
        case ResponseType.Success:
            request.resolve(params);
            break;
        case ResponseType.Error:
            request.reject(params);
            break;
        default:
            const isAppObjectOrCustom = responseType === ResponseType.AppNotify
                || responseType === ResponseType.AppRequest
                || responseType >= ResponseType.Custom;
            if (isAppObjectOrCustom && request.responseHandler) {
                request.responseHandler(params, responseType);
            }
    }
}
function parseResult(resultJson) {
    const result = JSON.parse(resultJson);
    if ("error" in result) {
        throw new errors_1.TonClientError(result.error.code, result.error.message, result.error.data);
    }
    return result.result;
}
//# sourceMappingURL=bin.js.map