"use strict";
/*
 * Copyright 2018-2020 TON DEV SOLUTIONS LTD.
 *
 * Licensed under the SOFTWARE EVALUATION License (the "License"); you may not use
 * this file except in compliance with the License.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific TON DEV software governing permissions and
 * limitations under the License.
 *
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TonClient = void 0;
const modules_1 = require("./modules");
const bin_1 = require("./bin");
class TonClient {
    constructor(config) {
        this.context = null;
        this.config = config !== null && config !== void 0 ? config : {};
        this.client = new modules_1.ClientModule(this);
        this.crypto = new modules_1.CryptoModule(this);
        this.abi = new modules_1.AbiModule(this);
        this.boc = new modules_1.BocModule(this);
        this.processing = new modules_1.ProcessingModule(this);
        this.utils = new modules_1.UtilsModule(this);
        this.net = new modules_1.NetModule(this);
        this.tvm = new modules_1.TvmModule(this);
    }
    static set default(client) {
        this._default = client;
    }
    static get default() {
        if (this._default === null) {
            this._default = new TonClient(this._defaultConfig);
        }
        return this._default;
    }
    static set defaultConfig(config) {
        this._defaultConfig = config;
    }
    static get defaultConfig() {
        return this._defaultConfig;
    }
    static useBinaryLibrary(loader) {
        bin_1.useLibrary(loader);
    }
    static toKey(d) {
        return toHex(d, 256);
    }
    static toHash64(d) {
        return toHex(d, 64);
    }
    static toHash128(d) {
        return toHex(d, 128);
    }
    static toHash256(d) {
        return toHex(d, 256);
    }
    static toHash512(d) {
        return toHex(d, 512);
    }
    static toHex(dec, bits = 0) {
        return toHex(dec, bits);
    }
    close() {
        const context = this.context;
        if (context !== null) {
            this.context = null;
            bin_1.destroyContext(context);
        }
    }
    request(functionName, functionParams, responseHandler) {
        return __awaiter(this, void 0, void 0, function* () {
            let context;
            if (this.context !== null) {
                context = this.context;
            }
            else {
                context = yield bin_1.createContext(this.config);
                this.context = context;
            }
            return bin_1.request(context, functionName, functionParams, responseHandler !== null && responseHandler !== void 0 ? responseHandler : (() => {
            }));
        });
    }
    resolve_app_request(app_request_id, result) {
        return __awaiter(this, void 0, void 0, function* () {
            if (app_request_id) {
                yield this.client.resolve_app_request({ app_request_id, result: { type: "Ok", result } });
            }
        });
    }
    reject_app_request(app_request_id, error) {
        return __awaiter(this, void 0, void 0, function* () {
            if (app_request_id) {
                yield this.client.resolve_app_request({
                    app_request_id,
                    result: { type: "Error", text: error.message }
                });
            }
        });
    }
}
exports.TonClient = TonClient;
TonClient._defaultConfig = {
    network: {
        endpoints: ["main.ton.dev"],
    },
};
TonClient._default = null;
// Converts value to hex
function toHex(value, bits) {
    let hex;
    if (typeof value === 'number' || typeof value === 'bigint') {
        hex = value.toString(16);
    }
    else if (typeof value === 'string') {
        if (value.startsWith('0x')) {
            hex = value.substr(2);
        }
        else {
            hex = decToHex(value);
        }
    }
    else {
        hex = value.toString();
    }
    let len = bits / 4;
    while (hex.length > len && hex.startsWith('0')) {
        hex = hex.substr(1);
    }
    return hex.padStart(len, '0');
}
function decToHex(dec) {
    var _a;
    let bigNum = [];
    for (let i = 0; i < dec.length; i += 1) {
        const d = ((_a = dec.codePointAt(i)) !== null && _a !== void 0 ? _a : 0) - 48;
        const mul8 = shl(bigNum, 3);
        const mul2 = shl(bigNum, 1);
        const mul10 = add(mul8, mul2);
        bigNum = add(mul10, [d]);
    }
    let hex = '';
    for (let i = bigNum.length - 1; i >= 0; i -= 1) {
        hex += bigNum[i].toString(16).padStart(4, '0');
    }
    return hex;
}
function shl(bigNum, bits) {
    let rest = 0;
    const result = [];
    for (let i = 0; i < bigNum.length; i += 1) {
        let v = (bigNum[i] << bits) + rest;
        result.push(v & 0xFFFF);
        rest = (v >> 16) & 0xFFFF;
    }
    if (rest > 0) {
        result.push(rest);
    }
    return result;
}
function add(a, b) {
    let rest = 0;
    const result = [];
    const len = Math.max(a.length, b.length);
    for (let i = 0; i < len; i += 1) {
        let v = (i < a.length ? a[i] : 0) + (i < b.length ? b[i] : 0) + rest;
        result.push(v & 0xFFFF);
        rest = (v >> 16) & 0xFFFF;
    }
    if (rest > 0) {
        result.push(rest);
    }
    return result;
}
//# sourceMappingURL=client.js.map