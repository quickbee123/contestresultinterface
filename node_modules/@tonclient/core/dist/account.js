"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Account = exports.AccountError = void 0;
const modules_1 = require("./modules");
const client_1 = require("./client");
class AccountError extends Error {
    static missingTVC() {
        return new AccountError("Can't calculate deploy params: missing required TVC.");
    }
}
exports.AccountError = AccountError;
class Account {
    constructor(contract, options) {
        var _a, _b, _c, _d;
        this.contract = contract;
        this.syncLastTransLt = null;
        this.client = (_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client_1.TonClient.default;
        this.abi = modules_1.abiContract(contract.abi);
        this.signer = (_b = options === null || options === void 0 ? void 0 : options.signer) !== null && _b !== void 0 ? _b : modules_1.signerNone();
        this.address = (_c = options === null || options === void 0 ? void 0 : options.address) !== null && _c !== void 0 ? _c : null;
        this.initData = (_d = options === null || options === void 0 ? void 0 : options.initData) !== null && _d !== void 0 ? _d : null;
        this.cachedBoc = null;
    }
    static set giver(giver) {
        this._giver = giver;
    }
    static createGiver() {
        const giver = new Account(GiverContract, {
            client: client_1.TonClient.default,
            address: GiverContract.defaultAddress,
            signer: modules_1.signerKeys(GiverContract.defaultKeys),
        });
        return (address, value) => __awaiter(this, void 0, void 0, function* () {
            yield giver.run("sendTransaction", {
                dest: address,
                value,
                bounce: false,
            });
        });
    }
    static get giver() {
        if (this._giver === null) {
            this._giver = this.createGiver();
        }
        return this._giver;
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            let address = this.address;
            if (address === null) {
                const deployParams = this.getParamsOfDeployMessage({
                    initFunctionName: null,
                });
                address = (yield this.client.abi.encode_message(deployParams)).address;
                this.address = address;
            }
            return address;
        });
    }
    getParamsOfDeployMessage(options) {
        var _a;
        if (!this.contract.tvc) {
            throw AccountError.missingTVC();
        }
        const params = {
            abi: this.abi,
            signer: this.signer,
            deploy_set: {
                tvc: this.contract.tvc,
            },
        };
        if (this.initData) {
            params.deploy_set.initial_data = this.initData;
        }
        if ((options === null || options === void 0 ? void 0 : options.initFunctionName) !== null) {
            params.call_set = {
                function_name: (_a = options === null || options === void 0 ? void 0 : options.initFunctionName) !== null && _a !== void 0 ? _a : "constructor",
            };
            if ((options === null || options === void 0 ? void 0 : options.initInput) !== undefined) {
                params.call_set.input = options.initInput;
            }
        }
        return params;
    }
    /**
     * Deploys account into network
     * @param options
     */
    deploy(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const deployParams = this.getParamsOfDeployMessage(options);
            const useGiver = options === null || options === void 0 ? void 0 : options.useGiver;
            const giver = useGiver === true ? Account.giver : useGiver;
            this.address = (yield this.client.abi.encode_message(deployParams)).address;
            if (giver) {
                yield giver(this.address, 10000000000);
            }
            const result = yield this.client.processing.process_message({
                message_encode_params: deployParams,
                send_events: false,
            });
            this.needSyncWithTransaction(result.transaction);
            return result;
        });
    }
    /**
     * Process message on network and returns detailed information
     * about results including produced transaction and messages.
     * @param functionName
     * @param input
     * @param options
     */
    run(functionName, input, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const result = (yield this.client.processing.process_message({
                message_encode_params: {
                    address: yield this.getAddress(),
                    abi: this.abi,
                    signer: (_a = options === null || options === void 0 ? void 0 : options.signer) !== null && _a !== void 0 ? _a : this.signer,
                    call_set: {
                        function_name: functionName,
                        input,
                    },
                },
                send_events: false,
            }));
            this.needSyncWithTransaction(result.transaction);
            return result;
        });
    }
    /**
     * Evaluates message on local TVM and returns decoded output
     * @param functionName
     * @param input
     * @param options
     */
    runLocal(functionName, input, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const message = yield this.client.abi.encode_message({
                address: yield this.getAddress(),
                abi: this.abi,
                signer: this.signer,
                call_set: {
                    function_name: functionName,
                    input,
                },
            });
            let result;
            if (options === null || options === void 0 ? void 0 : options.performAllChecks) {
                result = yield this.client.tvm.run_executor({
                    account: modules_1.accountForExecutorAccount(yield this.boc()),
                    abi: this.abi,
                    message: message.message,
                    return_updated_account: true,
                });
            }
            else {
                result = (yield this.client.tvm.run_tvm({
                    account: yield this.boc(),
                    abi: this.abi,
                    message: message.message,
                    return_updated_account: true,
                }));
            }
            if (result.account) {
                this.cachedBoc = result.account;
            }
            return result;
        });
    }
    needSyncWithTransaction(transaction) {
        if (!transaction.aborted && transaction.lt) {
            this.syncLastTransLt = transaction.lt;
            this.cachedBoc = null;
        }
    }
    /**
     * Returns raw data of the account in form of BOC.
     */
    boc() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.cachedBoc) {
                return this.cachedBoc;
            }
            const address = yield this.getAddress();
            const net = this.client.net;
            if (this.syncLastTransLt) {
                const accounts = yield net.query_collection({
                    collection: "accounts",
                    filter: {
                        id: { eq: address },
                        last_trans_lt: { ge: this.syncLastTransLt },
                    },
                    result: "boc",
                });
                if (accounts.result.length > 0) {
                    const boc = accounts.result[0].boc;
                    this.syncLastTransLt = null;
                    this.cachedBoc = boc;
                    return boc;
                }
            }
            const boc = (yield net.wait_for_collection({
                collection: "accounts",
                filter: { id: { eq: this.address } },
                result: "boc",
                timeout: 1000,
            })).result.boc;
            this.cachedBoc = boc;
            return boc;
        });
    }
    /**
     * Drops all cached and local data.
     */
    refresh() {
        this.cachedBoc = null;
    }
    /**
     * Returns parsed data of the account.
     */
    getAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.client.boc.parse_account({
                boc: yield this.boc(),
            })).parsed;
        });
    }
    /**
     * Free all internal resources related to this instance
     * and allocated inside core.
     *
     * It is a good practice to call this method when you have finished
     * with this Account object.
     *
     * Note that this instance still fully operable.
     * So you can continue to work with this instance.
     */
    free() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
}
exports.Account = Account;
Account._giver = null;
const GiverContract = {
    abi: {
        "ABI version": 2,
        header: ["time", "expire"],
        functions: [
            {
                name: "sendTransaction",
                inputs: [
                    {
                        "name": "dest",
                        "type": "address",
                    },
                    {
                        "name": "value",
                        "type": "uint128",
                    },
                    {
                        "name": "bounce",
                        "type": "bool",
                    },
                ],
                outputs: [],
            },
            {
                name: "getMessages",
                inputs: [],
                outputs: [
                    {
                        components: [
                            {
                                name: "hash",
                                type: "uint256",
                            },
                            {
                                name: "expireAt",
                                type: "uint64",
                            },
                        ],
                        name: "messages",
                        type: "tuple[]",
                    },
                ],
            },
            {
                name: "upgrade",
                inputs: [
                    {
                        name: "newcode",
                        type: "cell",
                    },
                ],
                outputs: [],
            },
            {
                name: "constructor",
                inputs: [],
                outputs: [],
            },
        ],
        data: [],
        events: [],
    },
    tvc: "",
    defaultAddress: "0:b5e9240fc2d2f1ff8cbb1d1dee7fb7cae155e5f6320e585fcc685698994a19a5",
    defaultKeys: {
        "public": "2ada2e65ab8eeab09490e3521415f45b6e42df9c760a639bcf53957550b25a16",
        "secret": "172af540e43a524763dd53b26a066d472a97c4de37d5498170564510608250c3",
    },
};
//# sourceMappingURL=account.js.map